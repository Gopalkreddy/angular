import { Component, Directive, signal } from "@angular/core"

install angular : npm install -g @angular/cli

with specific version : npm install -g @angular/cli@<version>

create new angular project : ng new <project-name>
serve angular project : cd <project-name> && ng serve
build angular project : ng build
for maintaining node versions : use nvm (Node Version Manager)
older version of node : nvm install <version>
switch node version : nvm use <version>
list installed node versions : nvm ls
list available node versions : nvm ls-remote

define angular component : ng generate component <component-name>
define angular service : ng generate service <service-name>
define angular module : ng generate module <module-name>
define angular directive : ng generate directive <directive-name>
what is component : A component controls a patch of screen called a view. It consists of a TypeScript class, an HTML template, and optional CSS styles.
what is service : A service is a class that provides specific functionality and can be shared across components.
example :
@Injectable({
  providedIn: 'root'
})
export class DataService {
  getData() {
    return ['Data1', 'Data2', 'Data3'];
  }
}
what is module : A module is a container that groups related components, services, directives, and pipes.
example :
@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
what is directive : A directive is a class that adds behavior to elements in your Angular applications.
example :
@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
  constructor(private el: ElementRef) {
    this.el.nativeElement.style.backgroundColor = 'yellow';
  }
}

data binding in angular : Data binding is a mechanism for coordinating parts of a template with parts of a component. It allows you to define communication between the component class and the template.

types of data binding in angular :
1. Interpolation: {{ value }}
2. Property Binding: [property]="value"
we can even use class and style bindings
3. Event Binding: (event)="handler()"
4. Two-Way Binding: [(ngModel)]="property"

signal in angular : Signals are a reactive primitive that allow you to create reactive state in your Angular applications. They enable automatic updates to the UI when the underlying data changes.    



export class SignalEx {
  title = signal('Hello, Angular Signals!');
  name =signal<string>('Gopal')
}   

for calling signal value use () parentheses like function call

example : 
In template : <h1>{{ title() }}</h1>
In component : console.log(this.title())

signal set value : use set() method

example :
this.title.set('New Title');

signal will work only in angular 16 and above versions with node 18 and above versions

control flow in angular : Control flow in Angular refers to the mechanisms that allow you to control the rendering of elements in your templates based on certain conditions or iterations. Angular provides structural directives for this purpose.

types of control flow directives in angular :
1. *ngIf : Conditionally includes or excludes a template based on the value of an expression.
2. *ngFor : Repeats a template for each item in a collection.
3. *ngSwitch : Conditionally includes one of several templates based on the value of an expression.

example of *ngIf :
In template :
<div *ngIf="isVisible">This content is visible.</div>

In component :
isVisible = true;

@if isVisible is true, the div will be rendered; otherwise, it will be removed from the DOM.

Routing in angular : Routing in Angular is a mechanism that allows you to navigate between different views or components within a single-page application (SPA). It enables you to define routes, which map URLs to specific components, allowing users to navigate through the application without reloading the entire page.

To set up routing in an Angular application, you typically follow these steps:

1. Import the RouterModule and Routes from @angular/router in your app.module.ts file.
2. Define your routes as an array of objects, where each object specifies a path and the corresponding component to render.
3. Use the RouterModule.forRoot() method to configure the router with your defined routes.
4. Add a <router-outlet> directive in your main template (usually app.component.html) to serve as a placeholder for the routed components.
5. Use routerLink directives in your templates to create navigation links.

Example:

In app.ts:
import { RouterLink, RouterModule, Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { AboutComponent } from './about/about.component';

In app.routes.ts:
export const routes: Routes = [
    {
        path: 'admin',
        component:Admin
    },
    {
        path: 'user',
        component: User
    },
    {
        path: 'control-flow',
        component: ContrlFlow
    },
    {
        path: 'data-binding',
        component: DataBinding
    }
];

RouterLink : The RouterLink directive is used to create navigation links in Angular applications. It allows you to define clickable elements that navigate to different routes defined in your routing configuration.

To use RouterLink, you typically bind it to a path defined in your routing configuration. When the user clicks on the element with the RouterLink directive, Angular's router will navigate to the specified route without reloading the entire page.

Example:

In template:
<a routerLink="/admin">Go to Admin</a>
<a routerLink="/user">Go to User</a>

In this example, clicking on the "Go to Admin" link will navigate to the /admin route, and clicking on the "Go to User" link will navigate to the /user route. The corresponding components for these routes will be rendered in the <router-outlet> defined in your main template.
  } 

  Directives used : two types of directives

  predefined directives : 
    *ngIf, *ngFor, *ngSwitch, ngClass, ngStyle, ngModel

    routing directives : routerLink, routerOutlet

  custom directives : user defined directives to add specific behavior to elements

types of directives in angular :

  1. Structural Directives : they change the structure of the DOM
     examples : *ngIf, *ngFor, *
     
     * These Structural Directives are deprecated in angular 16 and above versions

  2. Attribute Directives : they change the appearance or behavior of an element, component, or another directive.
     examples : ngClass, ngStyle, ngModel

Component life cycle in angular : Angular components have a well-defined lifecycle that consists of various phases from creation to destruction. Angular provides lifecycle hooks that allow you to tap into these phases and perform specific actions at different points in the component's lifecycle.

The main lifecycle hooks in Angular components are:

1. ngOnChanges: Called before ngOnInit and whenever one or more data-bound input properties change.
2. ngOnInit: Called once, after the first ngOnChanges. This is where you typically perform component initialization.
3. ngDoCheck: Called during every change detection run, allowing you to implement custom change detection.
4. ngAfterContentInit: Called once after the first ngDoCheck, after content (ng-content) has been projected into the component.
5. ngAfterContentChecked: Called after ngAfterContentInit and every subsequent ngDoCheck, after projected content has been checked.
6. ngAfterViewInit: Called once after the first ngAfterContentChecked, after the component's view and child views have been initialized.
7. ngAfterViewChecked: Called after ngAfterViewInit and every subsequent ngAfterContentChecked, after the component's view and child views have been checked.
8. ngOnDestroy: Called just before Angular destroys the component. This is where you typically perform cleanup tasks, such as unsubscribing from observables.
subcribe to observables in ngOnInit and unsubscribe in ngOnDestroy to prevent memory leaks.

By implementing these lifecycle hooks in your component class, you can manage the component's behavior and state throughout its lifecycle.

FormsModule in angular : FormsModule is an Angular module that provides support for template-driven forms. It includes directives and services that make it easier to create and manage forms in Angular applications.ngIf, *ngSwitch   
To use FormsModule in your Angular application, you need to import it from @angular/forms and include it in the imports array of your NgModule.

install bootstrap : npm install bootstrap

import bootstrapimportimport { SlicePipe } from "@angular/common"
 { pipe } from "rxjs"
 in angular.json file

"styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css",
              "src/styles.css"
            ],

package.json file also will have bootstrap entry in dependencies

"dependencies": {
    ...
    "bootstrap": "^5.3.0",
    ...
  },  
use bootstrap classes in angular components

example :
In template :
<button class="btn btn-primary">Primary Button</button>

pipes in angular : Pipes in Angular are a way to transform data in templates. They take input data and transform it into a desired output format. 
Pipes are used within template expressions to format data for display.

example :
In template :
<p>{{ birthday | date:'longDate' }}</p>

In component :
birthday = new Date(1990, 1, 1);

In this example, the date pipe formats the birthday property into a long date format for display in the template.

upppercase pipe : The uppercase pipe in Angular is used to transform a string to uppercase letters. It is a built-in pipe that can be used directly in Angular templates.

example :
In template :
<p>{{ 'hello world' | uppercase }}</p>

Output :
HELLO WORLD

lowercase pipe : The lowercase pipe in Angular is used to transform a string to lowercase letters. It is a built-in pipe that can be used directly in Angular templates.

example :
In template :
<p>{{ 'HELLO WORLD' | lowercase }}</p>

Output :
hello world

titlecase pipe : The titlecase pipe in Angular is used to transform a string so that the first letter of each word is capitalized. It is a built-in pipe that can be used directly in Angular templates.

example :
In template :
<p>{{ 'hello world from angular' | titlecase }}</p>

Output :
Hello World From Angular

SlicePipe : The SlicePipe in Angular is used to create a new array or string that is a subset of the original array or string. It allows you to specify a start index and an optional end index to extract a portion of the data.

example :
In template :
<p>{{ 'Hello Angular Developers' | slice:6:15 }}</p>

Output :
Angular D

In this example, the slice pipe extracts the substring from index 6 to index 15 of the original string.

JsonPipe  : The JsonPipe in Angular is used to convert a JavaScript object or array into a JSON string representation. It is particularly useful for debugging purposes, as it allows you to easily visualize the structure and content of complex objects in your templates.

example :
In template :
<p>{{ student | json }}</p>

In component :
student = {
  name: 'Gopal Reddy',
  age: 33,
  address: 'Hyderabad'
};

Output :
{
  "name": "Gopal Reddy",
  "age": 33,
  "address": "Hyderabad"
}

API integration in angular : API integration in Angular involves making HTTP requests to external APIs to fetch or send data. 
Angular provides the HttpClient module, which makes it easy to work with HTTP requests and responses.

To integrate an API in your Angular application, you typically follow these steps:

1. Import the HttpClientModule in your app.module.ts file and include it in the imports array of your NgModule.
2. Create a service that will handle the API calls using the HttpClient.
3. Use the service in your components to make API requests and handle the responses.

Example:

In app.module.ts:
import { HttpClientModule } from '@angular/common/http';

@NgModule({
  imports: [
    BrowserModule,
    HttpClientModule
  ],
  ...
})
export class AppModule { }

In data.service.ts:
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, using } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class DataService {
  private apiUrl = 'https://api.example.com/data';  
  constructor(private http: HttpClient) { }

  getData(): Observable<any> {
    return this.http.get<any>(this.apiUrl);
  }

  Forms are two types in angular :
1. Template-driven forms
2. Reactive forms

Template-driven forms : Template-driven forms are a way to create forms in Angular using directives in the template. They are simple to use and are suitable for small to medium-sized forms.

To create a template-driven form, you typically follow these steps:

1. Import the FormsModule in your app.module.ts file and include it in the imports array of your NgModule.
2. Use the ngModel directive in your template to bind form controls to component properties.
3. Handle form submission using the (ngSubmit) event.

Reactive forms : Reactive forms are a way to create forms in Angular using a model-driven approach. They provide more control and flexibility over form validation and state management.
To create a reactive form, you typically follow these steps:

1. Import the ReactiveFormsModule in your app.module.ts file and include it in the imports array of your NgModule.
2. Create a FormGroup and FormControl instances in your component to define the form structure.

userForm : FormGroup = new FormGroup({
    userId : new FormControl(0),
    emailId : new FormControl(''),
    password : new FormControl(''),
    fullName : new FormControl(''),
    mobileNo : new FormControl('')
  });

  formControlName directive in your template to bind form controls to the FormControl instances in your component.

    <input type="text" class="form-control" formControlName="fullName"  placeholder="Enter username">

3. Use the formGroup directive in your template to bind the form to the component's FormGroup instance.
4. Handle form submission using the (ngSubmit) event.

validation in angular forms : Validation in Angular forms is the process of ensuring that user input meets certain criteria before it is processed or submitted. Angular provides built-in validators as well as the ability to create custom validators for both template-driven and reactive forms.

example of validation in template-driven forms :
In template :
<input type="text" #fullname ="ngModel" required class="form-control" [(ngModel)]="userObject.fullName" placeholder="Enter username">
<div class="text-danger">{{fullname.errors?.['required'] ? 'Username is required' : ''}}</div>

In this example, the required attribute ensures that the fullName field is not left empty. If the user tries to submit the form without entering a username, an error message will be displayed.

example of validation in reactive forms :
In component :
userForm : FormGroup = new FormGroup({
    fullName : new FormControl('', [Validators.required, Validators.minLength(4)]),
    emailId : new FormControl('', [Validators.required, Validators.email]),
    password : new FormControl('', [Validators.required, Validators.minLength(6)]),
    mobileNo : new FormControl('', [Validators.required, Validators.pattern('^[0-9]{10}$')])
  });

In template :
<input type="text" class="form-control" formControlName="fullName" placeholder="Enter username">
<div class="text-danger" *ngIf="userForm.get('fullName')?.errors?.['required']">Username is required</div>
<div class="text-danger" *ngIf="userForm.get('fullName')?.errors?.['minlength']">Username must be at least 4 characters long</div>

In this example, the fullName field has multiple validators: it is required and must be at least 4 characters long. If the user input does not meet these criteria, appropriate error messages will be displayed.
    alert("User Updated Successfully");
      this.getUsers();
    }); 
  }

userForm.controls['userId'].errors to get specific control errors

@if(userForm.controls['emailId'].errors?.['required']){
{{userForm.controls['emailId'].errors?.['required'] ? 'Email is required' : ''}}


using controls property
@if(userForm.controls.emailId.errors?.['required']){
{{userForm.controls.emailId.errors?.['required'] ? 'Email is required' : ''}}
}

ng g p namespaceipe-ex : ng generate pipe namespaceipe-ex using angular cli command to generate custom pipe

custom pipe in angular : A custom pipe in Angular is a user-defined transformation function that can be used to format or transform data in templates. 
Custom pipes allow you to create reusable data transformation logic that can be applied to values in your Angular applications.

To create a custom pipe, you typically follow these steps:
1. Use the Angular CLI command ng generate pipe <pipe-name> to generate a new pipe file.
2. Implement the PipeTransform interface in your pipe class and define the transform method, which contains the logic for transforming the input value.
3. Use the @Pipe decorator to define the name of the pipe, which will be used in templates.
4. Register the pipe in the declarations array of your NgModule.

Example:

In pipe-ex.ts:
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'namespaceipeEx'
})
export class NamespaceipeEx implements PipeTransform {
  transform(value: string, ...args: any[]): string {
    // Custom transformation logic
    return value.toUpperCase(); // Example: Convert to uppercase
  }
} 

In template:
<p>{{ 'hello world' | namespaceipeEx }}</p>

Output :
HELLO WORLD